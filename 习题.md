# part01

## ch01 理解网络编程和套接字



> 1. 套接字在网络编程中的作用是什么？为什么称它为套接字？

网络编程就是编写程序让两台联网的计算机相互交换数据。

套接字是用于传输和接收数据的媒介，是网络传输用的软件、连接互联网的工具。

> 2. 在服务器端创建套接字后，会依次调用listen函数和accept函数。请比较并说明两者作用

Listen()将服务器端转换为可连接状态，等待客户端发起连接请求（监听）；

Accep是用于服务端接收处理客户端发来的连接请求。

二者存在逻辑上的先后关系。   

处于listen阶段的服务器已经做好了交换网络网络数据所需的准备工作，但并没有开放连接给客户端连（类似于餐厅装修好了，但未开业）。accept阶段循环监听，直到用客户端的连接到来。

> 3. Linux中，对套接字数据进行I/O时可以直接使用I/O相关函数；而在Windows中则不可以。为何？

因为linux不区分文件和套接字，因此可以通过文件I/O函数read和write进行数据传输。

而window严格区分，window下有专门的套接字I/O函数和专门的文件I/O函数。

> 4. 创建套接字后一般会给它分配地址，为什么？为了完成地址分配需要调用哪些函数？

为了区分Internet上的套接字，为其创建一个可供客户端连接的接口。

有了地址，客户端才能明确连接的目标，

 bind()

> 5. Linux中的文件描述符与Windows的句柄实际上非常类似。请以套接字为对象说明他们的含义。

Linux中的文件描述符是为了方便称呼 操作系统创建的文件/套件字 而赋予它们的整数值（编号）。

Windows的句柄相当于linux的文件描述符，分为文件句柄和套接字局部，两者有区别。

> 6. 底层文件I/O函数与ANSI标准定义的文件I/O函数之间有何区别？

【1】底层文件I/O又称为低级磁盘I/O, 标准I/O又称为高级磁盘I/O。

ANSI标准定义的I/O函数是与操作系统（内核）无关的以C标准写成的函数；相反，底层文件I/O函数是操作系统直接提供的。理论上ANSI标准I/O提供了某些机制，性能上优于底层I/O

Linux下既可以使用文件I/O, 也可以使用标准I/O。

而ANSI标准定义的文件I/O函数是用于windows的。

【2】标准I/O分为全缓冲，行缓冲，不缓冲三种形式；文件I/O为不带缓冲的I/O。

通过文件I/O读写文件时，每次操作都会进行系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统的开销。

标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，减少了系统调用的次数。

【3】文件I/O主要针对文件操作，它操作的是文件描述符；标准I/O针对的是控制台，它操作的是字符流。对于不同设备得特性不一样，必须有不同api访问才最高效。

文件I/O中使用文件描述符表示一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。

而标准I/O中使用FILE(流) 表示一个打开的文件，通常只用来访问普通文件

> 7. 参考本书给出的示例low_open.c和low_read.c,分别利用底层文件I/O和ANSI标准I/O编写文件复制程序。可任意指定复制程序的使用方法。

#### `low_cp.c`

```c++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#define BUF_SIZE 100 //实践中通常使用4096B的缓冲区

//low_cp.c : first open,then read and write

int main(void) {
    int src, dst;//定义源文件描述符,目的文件描述符
    int read_cnt;//用于接收read返回值
    char buf[BUF_SIZE];
    //buf:是一个字符数组(或缓冲区)，用于暂存从源文件读取的数据，然后将这些数据写入目标文件。
    //BUF_SIZE表示缓冲区的大小,即一次文件I/O操作能读取或写入的最大的数据块大小,由BUF_SIZE指定。
    //过小的缓冲区可能导致频繁的 I/O 操作，降低性能；而过大的缓冲区可能导致内存占用增加。

    //1.以只读方式打开源文件
    src = open("src.txt", O_RDONLY);
    //2.打开目标文件 dst.txt，如果不存在则创建，以写入方式打开，如果文件已存在则截断文件
    dst = open("dst.txt",O_CREAT|O_WRONLY|O_TRUNC);
    //3.检查文件是否成功打开
    if (src == -1) {
        puts("src.txt open error");
        return -1;
    }
    if (dst == -1) {
        puts("dst.txt open error");
        return -1;
    }
    //4.连续不断地从源文件读取数据块，并将其写入目标文件，直到源文件的末尾(read函数返回0时,说明读取的内容长度为0了，表示已经读取完整个文件，循环就会终止，整个文件复制过程完成)
    //检查 read_cnt 是否不等于0，即是否成功读取了数据。如果成功读取了数据，循环条件为真，继续执行循环体。
    while ((read_cnt = read(src, buf, BUF_SIZE)) != 0) { //read_cnt接收read返回值（成功时返回接收到的字节数，失败返回-1）
        write(dst, buf, read_cnt);
    }
    //5.关闭打开的文件描述符
    close(src);
    close(dst);
    return 0;
}
```

#### `ansi_cp.c`

 ```c
 #include <stdio.h>
 #include <stdlib.h>
 
 int main(void) {
     FILE*src,*dst;
     int read_cnt;
     src = fopen("src.txt", "r");
     dst = fopen("dst.txt","w");
 
     if (src == NULL) {
         puts("src.txt open error");
         return -1;
     }
     if (dst == NULL) {
         puts("dst.txt open error");
         return -1;
     }
     while ((read_cnt = fgetc(src)) != EOF) {
         fputc(read_cnt,dst);
     }
     fclose(src);
     fclose(dst);
     return 0;
 }
 ```

3. cp_with_args.c ==带参数的==

```c++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#define BUF_SIZE 100

int main(int argc, char *argv[]) {
    int src, dst;
    int read_cnt;
    char buf[BUF_SIZE];

    src = open(argv[1], O_RDONLY);
    dst = open(argv[2],O_CREAT|O_WRONLY|O_TRUNC);

    if (src == -1) {
        puts("src.txt open error");
        return -1;
    }
    if (dst == -1) {
        puts("dst.txt open error");
        return -1;
    }
    while ((read_cnt = read(src, buf, BUF_SIZE)) != 0) { //read_cnt接收read返回值（成功时返回接收到的字节数，失败返回-1）
        write(dst, buf, read_cnt);
    }
    close(src);
    close(dst);
    return 0;
}
```



## ch02 套接字类型与协议设置

> 1. 什么是协议？在收发数据中定义协议有何意义？

协议就是为了完成**数据交换**而定好的**约定**。因此，定义协议意味着对数据传输**所必需的的承诺**进行定义。

> 2. 面向连接的TCP套接字传输特性有3点，请分别说明。

1. 传输过程中**数据不会丢失**
2. **按序传输**数据
3. 传输的数据**不存在数据边界**

> 3. 下面哪些是面向消息的套接字的特性？

a.传输数据可能丢失

c.以快速传递为目的

e.与面向连接的套接字不同，不存在连接的概念

> 5. 何种类型的套接字不存在数据边界？这类套接字接收数据时需要注意什么？

面向连接类型的套接字TCP不存在数据边界。因此输入输出函数的响应次数不具有意义。**重要的不是函数的响应次数，而是数据的收发量**。因此，必须将**传输数据的量**和**接收数据的量**制作成编码，保证发**送数据的量和接收数据的量是一致**的，特别要注意是制作依赖函数响应次数判断代码。

> 6. 实现：
>
>     1. 客户端多次调用read，以读取服务器调用1次write函数传递的字符串。
>
>     2. 客户端调用1次read，以读取服务器端多次调用（次数自拟）write函数传递的字符串。
>
>         为达到这一目的，客户端需延迟调用read函数，因为客户端要等待服务器端传输所有数据。

### 客户端多次调用read函数，以读取服务器调用1次write函数传递的字符串

#### `tcp_serv_one_write.c`

```c++
#include <stdio.h>  // 包含标准输入输出库
#include <stdlib.h>  // 包含标准库
#include <string.h>  // 包含字符串处理函数库
#include <unistd.h>  // 包含Unix标准函数库
#include <arpa/inet.h>  // 包含IP地址转换函数
#include <sys/socket.h>  // 包含套接字函数库
void error_handling(char* message); //错误处理函数

int main(int argc, char* argv[]) {
    //argv[0]是程序名，argv[1]是端口号
    int serv_sock, clnt_sock; //serv_sock是服务端socket(门卫), clnt_sock是要与客户端通信的连接socket
    struct sockaddr_in serv_addr, clnt_addr; //保存地址信息的结构体变量
    socklen_t clnt_addr_size = sizeof(clnt_addr); //初始化 与客户端通信的连接socket的地址结构体的大小
    char message[] = "hello world!"; //要写入（传输）的数据
    if (argc != 2) { // 如果参数数量不为2（程序名称也是一个参数，还要有端口号参数）
        printf("Usage: %s <port>\n", argv[0]);
        exit(1); // 退出程序
    }
    //创建门卫socket
    serv_sock = socket(PF_INET, SOCK_STREAM, 0); 
    if (serv_sock == -1) error_handling("socket() errror");
    //初始化门卫socket的地址信息
    memset(&serv_addr, 0, sizeof(serv_addr)); //初始化serv_addr结构体为0
    serv_addr.sin_family = AF_INET; // 设置地址族
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); //设置IP
    serv_addr.sin_port = htons(atoi(argv[1])); //设置端口，argv[1]是传进来的第一个参
    //在门卫socket调用bind之前设置socket选项SO_REUSEADDR
    //表示允许地址重用, 否则close之后会有一个WAIT_TIME状态，使得该ip和端口仍被占用，产生bind() error.
    int on = 1;
    if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(int)) < 0)  error_handling("setsockopt() error");
    //命名socket（绑定地址）
    if (bind(serv_sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) == -1)  error_handling("bind() error");
    //准备好了之后，门卫socket设置监听队列长度，开始监听连接请求
    if (listen(serv_sock, 5) == -1) error_handling("listen() error"); 
    //接受客户端连接请求，创建新的套接字clnt_sock用于与客户端通信
    //这个新的套接字负责和【特定的】客户端进行数据交换，而原始的服务器套接字(serv_sock)继续监听新的连接请求
    clnt_sock = accept(serv_sock, (struct sockaddr*) &clnt_addr, &clnt_addr_size);
    //clnt_addr是成功与服务器建立连接的客户端socket地址结构体，clnt_addr_size是其长度（传入时为sizeof(clnt_addr)，传出为实际大小，会被填入客户端socket地址结构体中）
    if (clnt_sock == -1) error_handling("accept() error");
    //向clnt_sock中一次write()写入（传输）数据
    write(clnt_sock, message, sizeof(message));
    close(clnt_sock); //关闭与客户端通信的连接socket
    close(serv_sock); //关闭服务端socket(门卫)
    return 0;
}
void error_handling(char* message) {
    perror(message);  // 打印错误信息
    exit(1);  // 退出程序
}
```

#### `tcp_clnt_many_read.c`

```c++
#include <stdio.h>  // 包含标准输入输出库
#include <stdlib.h>  // 包含标准库
#include <string.h>  // 包含字符串处理函数库
#include <unistd.h>  // 包含Unix标准函数库
#include <arpa/inet.h>  // 包含IP地址转换函数
#include <sys/socket.h>  // 包含套接字函数库
void error_handling(char* message); //错误处理函数

int main(int argc, char* argv[]) {
    //argv[0]是程序名，argv[1]和argv[2]是目标服务器端套接字（门卫socket）的ip和端口号
    int clnt_sock;
    struct sockaddr_in serv_addr; //地址信息
    char message[30]; //保存从服务器端读取（接收）过来的数据
    if (argc != 3) { // 如果参数数量不为3（程序名称也是一个参数，还需要服务器门卫socket的ip和端口号两个参数）
        printf("Usage: %s <IP> <port>\n", argv[0]);
        exit(1);  // 退出程序
    }
    //创建客户端socket
    clnt_sock = socket(PF_INET, SOCK_STREAM, 0);
    if (clnt_sock == -1) error_handling("socket() errror");
    //初始化目标服务器套接字（门卫socket）的地址信息信息
    //不用初始化客户端套接字的地址信息，因为它们在之后调用connect()时会自动分配
    memset(&serv_addr, 0, sizeof(serv_addr)); //初始化serv_addr结构体为0
    serv_addr.sin_family = AF_INET; // 设置地址族
    serv_addr.sin_addr.s_addr = inet_addr(argv[1]); //设置IP
    serv_addr.sin_port = htons(atoi(argv[2])); //设置端口
    //向服务器端发送连接请求，同时connect()自动会给客户端socket分配ip和端口号
    if (connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) error_handling("connect() error");
    //完成连接后，从与之对应的服务器连接socket中读取（接收）数据
    int read_len = 0, idx = 0, str_len = 0;
    while (read_len = read(clnt_sock, &message[idx++], 1)){
        //read() p1: 要接收数据的socket，p2：要把数据读到哪里，p3: 要接收的最大字节数
        if(read_len == -1) error_handling("read() error");
        str_len += read_len;//统计read调用次数
    }
    printf("Message from server: %s \n", message); //打印读取（接收）的数据
    printf("Function read call count: %d \n", str_len); //打印read()调用次数
    close(clnt_sock);
    return 0;
}
void error_handling(char* message) {
    perror(message);  // 打印错误信息
    exit(1);  // 退出程序
}
```

#### 运行与结果显示：

```c++
# 服务器端
gcc   tcp_serv_one_write.c   -o   serv_one_wr
./serv_one_wr 9190  # 正常情况下程序将停留在此状态，因为服务器端调用的accept()还未返回，接下来运行客户端
# 客户端
gcc   tcp_clnt_many_read.c   -o   clnt_many_rd
./clnt_many_rd  127.0.0.1  9190
# 下面是客户端显示的结果
Message from server: hello world! 
Function read call count: 13 
```

### 服务器端多次调用（次数自拟）write函数传输数据，客户端调用1次read函数进行读取

#### `tcp_serv_many_write.c` 

```c++
#include <stdio.h>  // 包含标准输入输出库
#include <stdlib.h>  // 包含标准库
#include <string.h>  // 包含字符串处理函数库
#include <unistd.h>  // 包含Unix标准函数库
#include <arpa/inet.h>  // 包含IP地址转换函数
#include <sys/socket.h>  // 包含套接字函数库
void error_handling(char* message); //错误处理函数

int main(int argc, char* argv[]) {
    //argv[0]是程序名，argv[1]是端口号
    int serv_sock, clnt_sock; //serv_sock是服务端socket(门卫), clnt_sock是要与客户端通信的连接socket
    struct sockaddr_in serv_addr, clnt_addr; //保存地址信息的结构体变量
    socklen_t clnt_addr_size = sizeof(clnt_addr); //初始化 与客户端通信的连接socket的地址结构体的大小
    char message[] = "hello world!"; //要写入（传输）的数据
    if (argc != 2) { // 如果参数数量不为2（程序名称也是一个参数，还要有端口号参数）
        printf("Usage: %s <port>\n", argv[0]);
        exit(1); // 退出程序
    }
    //创建门卫socket
    serv_sock = socket(PF_INET, SOCK_STREAM, 0); 
    if (serv_sock == -1) error_handling("socket() errror");
    //初始化门卫socket的地址信息
    memset(&serv_addr, 0, sizeof(serv_addr)); //初始化serv_addr结构体为0
    serv_addr.sin_family = AF_INET; // 设置地址族
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); //设置IP
    serv_addr.sin_port = htons(atoi(argv[1])); //设置端口，argv[1]是传进来的第一个参
    //在门卫socket调用bind之前设置socket选项SO_REUSEADDR
    //表示允许地址重用, 否则close之后会有一个WAIT_TIME状态，使得该ip和端口仍被占用，产生bind() error.
    int on = 1;
    if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(int)) < 0)  error_handling("setsockopt() error");
    //命名socket（绑定地址）
    if (bind(serv_sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) == -1)  error_handling("bind() error");
    //准备好了之后，门卫socket设置监听队列长度，开始监听连接请求
    if (listen(serv_sock, 5) == -1) error_handling("listen() error"); 
    //接受客户端连接请求，创建新的套接字clnt_sock用于与客户端通信
    //这个新的套接字负责和【特定的】客户端进行数据交换，而原始的服务器套接字(serv_sock)继续监听新的连接请求
    clnt_sock = accept(serv_sock, (struct sockaddr*) &clnt_addr, &clnt_addr_size);
    //clnt_addr是成功与服务器建立连接的客户端socket地址结构体，clnt_addr_size是其长度（传入时为sizeof(clnt_addr)，传出为实际大小，会被填入客户端socket地址结构体中）
    if (clnt_sock == -1) error_handling("accept() error");    
    //向客户端套接字中多次write()写入（传输）数据
    //write(clnt_sock, message, 4);
    //write(clnt_sock, message + 4, 4);
    //write(clnt_sock, message + 8, 4);
    //write(clnt_sock, message + 12, sizeof(message) - 12);

    //或者写成：
    int inc = 0, len = strlen(message);
    while (len--) 
        if (write(clnt_sock, message + inc++, 1) == -1) error_handling("write() error");
    //如果第二个参数写成message++则会报错error: lvalue required as increment operand，因为++左侧被赋值的数必须是变量，而不能是常量，除了显而易见的常量之外，数组的首地址（比如这里的message），函数地址...都是常量
    close(clnt_sock); //关闭与客户端通信的连接socket
    close(serv_sock); //关闭服务端socket(门卫)
    return 0;
}
void error_handling(char* message) {
    perror(message);  // 打印错误信息
    exit(1);  // 退出程序
}
```

#### `tcp_clnt_one_read.c`

```c++
#include <stdio.h>  // 包含标准输入输出库
#include <stdlib.h>  // 包含标准库
#include <string.h>  // 包含字符串处理函数库
#include <unistd.h>  // 包含Unix标准函数库
#include <arpa/inet.h>  // 包含IP地址转换函数
#include <sys/socket.h>  // 包含套接字函数库
void error_handling(char* message); //错误处理函数

int main(int argc, char* argv[]) {
    //argv[0]是程序名，argv[1]和argv[2]是目标服务器端套接字（门卫socket）的ip和端口号
    int clnt_sock;
    struct sockaddr_in serv_addr; //地址信息
    char message[30]; //保存从服务器端读取（接收）过来的数据
    if (argc != 3) { // 如果参数数量不为3（程序名称也是一个参数，还需要服务器门卫socket的ip和端口号两个参数）
        printf("Usage: %s <IP> <port>\n", argv[0]);
        exit(1);  // 退出程序
    }
    //创建客户端socket
    clnt_sock = socket(PF_INET, SOCK_STREAM, 0);
    if (clnt_sock == -1) error_handling("socket() errror");
    //初始化目标服务器套接字（门卫socket）的地址信息信息
    //不用初始化客户端套接字的地址信息，因为它们在之后调用connect()时会自动分配
    memset(&serv_addr, 0, sizeof(serv_addr)); //初始化serv_addr结构体为0
    serv_addr.sin_family = AF_INET; // 设置地址族
    serv_addr.sin_addr.s_addr = inet_addr(argv[1]); //设置IP
    serv_addr.sin_port = htons(atoi(argv[2])); //设置端口
    //向服务器端发送连接请求，同时connect()自动会给客户端socket分配ip和端口号
    if (connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) error_handling("connect() error");
    //完成连接后，从与之对应的服务器连接socket中读取（接收）数据
    int i;
    for (i = 0; i < 100; ++i) printf("Wait time %d \n", i); 
    //由于服务器端是多次调用write()传输数据，客户端调用一次read()读取，而TCP套接字传输的数据是不存在数据边界的，因此客户端需延迟调用read()等待服务器端传输所有数据
    //这种让CPU执行多余认为以延迟代码运行的方式称为"Busy Waiting",使用得当就能成功延迟客户端read()函数的调用
    read(clnt_sock, &message, sizeof(message));
    printf("Message from server: %s \n", message); //打印读取（接收）的数据
    close(clnt_sock);
    return 0;
}
void error_handling(char* message) {
    perror(message);  // 打印错误信息
    exit(1);  // 退出程序
}
```

#### 运行与结果显示：

```c++
# 服务器端
gcc tcp_serv_many_write.c -o serv_many_wr
./serv_many_wr 9190  # 正常情况下程序将停留在此状态，因为服务器端调用的accept()还未返回，接下来运行客户端
# 客户端
gcc tcp_clnt_one_read.c -o clnt_one_rd
./clnt_one_rd 127.0.0.1 9190
# 下面是客户端显示的结果
Wait time 0 
Wait time 1 
····················
Wait time 99
Message from server: hello world! 
```

## ch03 地址族与数据序列

![image-20231204124655303](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312041246363.png)

> 1. IP地址族IPv4和IPv6有何区别？在何种背景下诞生了IPv6?

- 位数不同。IPV4是4字节（32位）地址族，IPV6是16字节（128位）地址族；

- ip地址面临耗尽。

> 2. 通过IPV4网络ID、主机ID及路由器的关系，说明向公司局域网中的计算机传输数据的过程

- 先向目标IP**所属的网络**传输数据，此时使用的是IP地址中的网络ID。
- 数据传到路由器，路由器将参照IP地址的主机号查找路由表，从对应的网口发送数据，数据经过路由器转发最终送到目标主机。

> 3. 套接字地址分为IP地址和端口号。为什么需要IP地址和端口号？或者说，通过IP可以区分哪些对象？通过端口号可以区分哪些对象？

- ip地址是为了区分网络上的主机
- 端口号是为了区分同一主机下的不同的SOCKET，将数据交给对应的进程，确保程序进程都能准确收发数据。

> 4. 请说明IP地址分类方法，并说出下面这些IP地址的分类：
>     - 214.121.212.102
>     - 120.101.122.89
>     - 129.78.102.211

A类：**0**开头，第一个字节表示的值的范围是**1**-127

B类：**10**开头，第一个字节表示的值的范围是**128**-191

C类：110开头，第一个字节表示的值的范围是**192**-223

- 214.121.212.102：C类
- 120.101.122.89：A类
- 129.78.102.211：B类

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312041014734.png)![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312041014731.png)

> 5. 计算机通过路由器或交换机连接到互联网。请说出路由器和交换机的作用

- 交换机：
    - 用于电（光）信号转发
    - 作用于链路层，依靠 MAC 地址过滤，转发

- 路由器：
    - 连接两个或多个网络，在网络间起网关的作用
    - 作用于网络层，依靠IP地址寻址，转发

```c++
路由器（Router）和交换机（Switch）的主要作用与区别：
【路由器】的作用与特点：
1. 路由器工作在网络层（第三层），负责在不同网络之间转发数据包。
2. 路由决策： 路由器通过查看目标地址（IP地址）来决定将数据包传送到网络的哪个部分。
3. 子网划分： 路由器能够将一个大网络划分成多个子网，提高网络的性能和安全性。
4. 支持多协议： 路由器能够处理多种网络协议，例如IP、IPv6、RIP、OSPF等。
5. 网络隔离： 路由器能够隔离不同的网络，提高网络的安全性。
6. 路由表： 路由器使用路由表来确定数据包的最佳路径。
【交换机】的作用与特点：
1. 交换机工作在数据链路层（第二层），主要处理MAC地址。
2. 转发帧： 交换机通过学习MAC地址表，将数据帧从一个端口转发到另一个端口，提高数据传输效率。
3. 内部交换表： 交换机内部维护一个交换表，记录MAC地址和相应的端口。
4. 广播域划分： 交换机能够划分广播域，减少网络中的广播流量。
5. 高性能： 交换机通常有较高的转发速度，适用于局域网中的高带宽要求。
6. 适用于局域网： 交换机主要用于连接局域网内的设备，提供高速、低延迟的数据传输。
《区别总结》：
1.工作层次： 路由器工作在网络层，而交换机工作在数据链路层。
2.决策侧重： 路由器根据IP地址进行决策，而交换机根据MAC地址进行转发。
3.隔离能力： 路由器能够隔离不同的网络，而交换机主要用于连接同一网络内的设备。
4.协议支持： 路由器支持多种网络协议，而交换机主要处理局域网内的数据帧。
5.广播域： 路由器划分广播域，而交换机通常不跨越广播域。

综合来说，路由器主要用于连接不同网络，实现不同网络之间的通信，而交换机主要用于连接同一网络内的设备，提供高效的内部数据传输。在一个复杂的网络中，通常会同时使用路由器和交换机以满足不同的需求。
```

> 6. 什么是知名端口？其范围是多少？知名端口中具有代表性的HTTP和FTP端口号各是多少？

- 1-1023
- HTTP：80；FTP：21

TCP:21。

> 7. bind函数原型如下:
>
>     `int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);`
>     而调用是：`bind(serv_sock, (struct sockaddr *) &serv_addr, sizeof(serv_addr));`
>     （此处传入的serv_addr是`sockaddr_in`类型的结构体变量）
>
>     **为什么原型中第二个参数是`sockaddr`结构体变量, 但调用时传入的是`sockaddr_in`结构体变量？**

- 因为`sockaddr`结构体，很难分配IP地址和端口号的空间大小(因为其并非只为IPv4设计，所以要兼容)，所以它将IP地址和端口号合并到一起用一个成员`sa_data`表示。

- 因此对于IP地址和端口号的分配，可先通过`sockaddr_in`完成，之后再强制转换成`sockaddr`类型。

（因为两个结构体的长度相同，都是16字节，强制转换类型时不会丢失字节，也没有多余的字节）

> 8. 请解释大端序、小端序、网络字节序，并说明为何需要网络字节序

- 大端序：高位存低地址
- **小端序**：高位存高地址（大部分CPU都是，因此也叫主机序）
- **网络字节序**：是网络传输数据的标准，即**大端序**

> 9. 大端计算机希望将4字节整型数据12传到小端序计算机。请说出数据传输过程中发生的字节序变换过程

12的二进制形式是：0 | 0 | 0 | 000C 

- 大端计算机，因此是高位存低字节，从低地址到高地址为：0 | 0 ，0 | 000C 

- 网络字节序是大端序，因此转换后不变；
- 传到小端序主机时要将大端序转换为小端序，从低地址到高地址为：0 | 000C，0 | 0 

> 10. 怎么表示回送地址？其含义是什么？如果向回送地址传输数据将会发生什么情况？

- 回送地址：127.0.0.1，表示计算机本身。

- 数据不进行网络传输而是直接返回。

## ch04  基于TCP的服务端/客户端（1）

> 1. 请说明TCP/IP的4层协议栈，并说明TCP和UDP套接字经过的层级结构差异。

应用层-->传输层-->网络层-->链路层（网络接口层）。

差异是：在传输层上TCP经过的是TCP层，而UDP经过的是UDP层。

> 2. 请说出TCP/IP协议栈中链路层和IP层的作用，并给出二者关系。

链路层的作用是在局域网上，根据mac地址，传输数据报（下一跳）；

ip层的作用是在因特网上，根据ip，传输数据报（端对端）；

二者关系：**IP层负责以链路层为基础的数据传输**

> 3. 为何需要把TCP/IP协议栈分成4层（或7层)?结合开放式系统回答。

分层的好处：各层之间是独立的，灵活性好，结构上可以分隔开，易于实现和维护，能促进标准化工作。

> 4. 客户端调用connect函数向服务器端发送连接请求。服务器端调用哪个函数后，客户端可
>     以调用connect函数?

listen()

> 5. 什么时候创建连接请求等待队列?它有何作用?与accept有什么关系?

调用listen()时。

作用：调用listen创建的连接请求等待队列是存储客户端连接请求信息的空间；

关系：accept函数调用后，将存储的连接请求信息取出，与客户端建立连接。

> 6. 客户端中为何不需要调用bind函数分配地址?如果不调用bind函数，那何时、如何向套
>     接字分配IP地址和端口号?

客户端是请求连接的程序，不是一个接收连接的程序。所以，指导服务器的地址信息是更重要的因素，没有必要通过bind函数明确地分配地址信息。但是，要想和服务器通信，必须将自己的地址信息分配到套接字上，因此，在connect函数调用时，系统会自动为套接字分配ip和端口号.

## ch05 基于TCP的服务端/客户端（2）

> 1. 请说明TCP套接字连接设置的三次握手过程。尤其是3次数据交换过程每次收发的数据内容。
> 2. 请通过ACK和SEQ说明TCP通过何种机制保证丢失数据的可靠传输。
> 3. TCP套接字中调用write和read函数时数据如何移动？结合I/O缓冲进行说明
> 4. 对方主机的输入缓冲剩余50字节空间时，若本方主机通过write函数请求传输70字节，问TCP如何处理这种情况？
> 5. 
> 6. 创建收发文件的服务器端/客户端，实现顺序如下：
>     - 客户端接受用户输入的传输文件名。
>     - 客户端请求服务器端传输该文件名所指文件。
>     - 如果指定文件存在，服务器端就将其发送给客户端;反之，则断开连接。

### 1. 

![image-20231217213858203](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312172138244.png)

**初始状态**：客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手。

1. **第一次握手**：客户端给服务端发一个 SYN 报文段，此时客户端进入` SYN_SENT `状态。（SYN=1的报文段不能携带数据）
2. **第二次握手**：服务器收到客户端的 SYN 报文段之后，向客户端发送SYN+ACK同步确认报文段，此时服务器进入`SYN_RECV`状态
3. **第三次握手**：客户端收到 SYN 报文之后，发送ACK确认报文段，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。

### 2. 

seq用于给数据字节编号，ack用于确认收到编号的信息。

每次传输信息时同时发送seq(表示发送数据最后一个字节的编号)，收到数据的主机以seq+1为ack回复对方，表示本端已收到前N个字节的数据，希望接收从N+1开始的数据。

通过这种机制，传输数据的主机就知道数据是否被正确接收。在不正确传输时，可以重传数据。

### 3. 

当write函数被调用时，数据就会向端口的输出缓冲区移动，然后经过网络传输传输到对方主机套接字的输入缓冲。输入缓冲中存储的数据通过read函数的响应来读取。

### 4. 

先传输50字节，等到对方主机的输入缓存中的数据被读走一部分有剩余空间了之后再传输剩下的数据。总之传输的数据不能超过对方输入缓冲的大小 

### 6. 

#### `file_serv.c`

```c++
#include <stdio.h>     
#include <stdlib.h>    
#include <string.h>     
#include <unistd.h>
#include <arpa/inet.h>  
#include <sys/socket.h> 

#define BUF_SIZE 30 
void error_handling(char* message);

int main(int argc, char* argv[]) {
    int  serv_sock, clnt_sock;
    FILE *fp;
    struct sockaddr_in serv_adr, clnt_adr; 
    socklen_t clnt_adr_sz; 
    char buf[BUF_SIZE]; //存放从文件中读到的数据
    char filename[BUF_SIZE]; //存放客户端传输过来的文件名字符串
    
    if(argc != 2) { 
        printf("Usage : %s <port>\n", argv[0]);
        exit(1);
    }   

    serv_sock = socket(PF_INET, SOCK_STREAM, 0); 
    if(serv_sock == -1) error_handling("socket() error");

    memset(&serv_adr, 0, sizeof(serv_adr)); 
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_adr.sin_port = htons(atoi(argv[1])); 

    int on = 1;
    if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(int)) < 0)  error_handling("setsockopt() error");
    
    if(bind(serv_sock, (struct sockaddr*) &serv_adr, sizeof(serv_adr)) == -1) error_handling("bind() error"); 
    
    if(listen(serv_sock, 5) == -1) error_handling("listen() error");
    
    clnt_adr_sz = sizeof(clnt_adr); 
    clnt_sock = accept(serv_sock, (struct sockaddr*) &clnt_adr, &clnt_adr_sz); 
    if(clnt_sock == -1) error_handling("accept() error");
    
    // Read data from the client to filename[]
    int str_len = 0, read_cnt = 0;
    read(clnt_sock, filename, BUF_SIZE); 
    if ((fp = fopen(filename, "rb")) == NULL) printf("File Open Failed ! \n");
    else{
        printf("File Open Success ! \n");
        while (1) {
                read_cnt = fread((void*)buf, 1, BUF_SIZE, fp);
                //从fp文件描述符中读数据到buf
                if (read_cnt < BUF_SIZE)  {
                    write(clnt_sock, buf, read_cnt); //将从文件中读到的read_cnt个字节写入客户端
                    break; //写完就退出
                }
                //如果read_cnt >= BUF_SIZE，也只能先将BUF_SIZE大小的数据写到客户端，之后继续循环传剩下的
                write(clnt_sock, buf, BUF_SIZE); 
        }   
    }
    fclose(fp);
    close(clnt_sock); 
    close(serv_sock); 
    return 0;
}
void error_handling(char* message) {
    perror(message);  
    exit(1);  
}
```

#### `file_clnt.c`

```c++
#include <stdio.h>     
#include <stdlib.h>    
#include <string.h>     
#include <unistd.h>
#include <arpa/inet.h>  
#include <sys/socket.h> 
#define BUF_SIZE 30 
void error_handling(char* message);

int main(int argc, char* argv[]) {
    int clnt_sock;
    struct sockaddr_in serv_adr; 
    FILE *fp;
    char buf[BUF_SIZE]; //存放从服务器端接收过来的数据
    char filename[BUF_SIZE]; //存放文件名
    
    if(argc != 3) { 
        printf("Usage : %s <IP> <port>\n", argv[0]);
        exit(1);
    }   
    
    clnt_sock = socket(PF_INET, SOCK_STREAM, 0); 
    if(clnt_sock == -1) error_handling("socket() error");
    
    memset(&serv_adr, 0, sizeof(serv_adr)); 
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_addr.s_addr = inet_addr(argv[1]); 
    serv_adr.sin_port = htons(atoi(argv[2])); 
    
    if(connect(clnt_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr)) == -1) error_handling("connect() error");    
    else puts("Connected!");
 
    fputs(" filename : ", stdout); 
    scanf("%s", &filename);
    //将文件名传输给服务器端
    write(clnt_sock, filename, strlen(filename));
    int read_cnt = 0;
    //while括号内语句的作用：将读到的文件数据写入到保存文件数据的buf缓冲区中
    // fwrite 函数用于将刚刚从服务器端读到的、read_cnt大小的、存在buf中的数据写入fp文件描述符表示的文件中
    while ((read_cnt = read(clnt_sock, buf, BUF_SIZE)) != 0) fwrite((void*)buf, sizeof(char), read_cnt, fp);
    // size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
    // - const void *ptr : 指针指向要写出数据的内存首地址 
    // - size_t size : 要写出数据的 基本单元 的字节大小(单位大小)
    // - size_t nmemb : 要写出数据的 基本单元 的个数 
    // - FILE *stream : 打开的文件指针 
    puts("received!");

    fclose(fp);
    close(clnt_sock);
    return 0;
}
void error_handling(char* message) {
    perror(message); 
    exit(1);  
}
```

#### 运行结果

## ch06 基于UDP的服务端/客户端

> 1. UDP为什么比TCP速度快？为什么TCP数据传输可靠而UDP数据传输不可靠？
> 2. 下列不属于UDP特点的是？
>     - a.UDP不同于TCP，不存在连接的概念，所以不像TCP那样只能进行一对一的数据传输。
>     - b.利用UDP传输数据时，如果有2个目标，则需要2个套接字。
>     - c. UDP套接字中无法使用已分配给TCP的同一端口号。
>     - d.UDP套接字和TCP套接字可以共存。若需要,可以在同一主机进行TCP和UDP数据传输。
>     - e.针对UDP函数也可以调用connect函数，此时UDP套接字跟TCP套接字相同，也需要经过3次握手过程。
> 3. UDP数据包向对方主机的UDP套接字传递过程中，IP和UDP分别负责哪些部分？
> 4. UDP一般比TCP快，但根据交换数据的特点，其差异可大可小。请说明何种情况下UDP的性能优于TCP
> 5. 客户端TCP套接字调用connect函数时自动分配IP和端口号。UDP中不调用bind函数，那何时分配IP和端口号？
> 6. TCP客户端必须调用connect函数，而UDP中可以选择性调用。请问，在UDP中调用connect函数有哪些好处？
> 7. 请参考本章给出的uecho_sev.c和uecho_clnt.c，编写示例使服务器端和客户端轮流收发消息。收发的消息均要输出到控制台窗口

### 1. 

UDP是面向报文、无连接的传输层协议。UDP尽最大努力交付数据但不保证可靠传输。

TCP是面向字节流、有连接的传输层协议。TCP保证可靠传输。

**TCP可靠和速度慢的原因：**TCP有流量控制机制，保证了消息可靠传输，但因其复杂性从而限制了消息的传输(体现在速度上)

### 2. 

看清楚！是不属于！！！

:x: ~~a、d~~、e

:heavy_check_mark: b、c、e

关于c：UDP套接字是可以使用已分配给TCP的同一端口号的。因为

> **服务器与客户端的通信是通过[五元组]来区分的，"五元"通常是指：源IP地址，源端口，目的IP地址，目的端口和传输层协议（TCP/UDP）。五元组能够区分不同会话，并且对应的会话是唯一的。通过五元组我们就可以实现一次找到一次通信的来源和去处。**

关于e：UDP可以调用connect函数，但是只是保持连接，提高了效率，但是并不会进行三次握手(从三次握手内容分析也可知道是针对TCP用的)

### 3. 

IP负责链路选择，在整个因特网中找到目的主机；

UDP负责端到端的传输。

### 4. 

在传输数据少，又要频繁传输数据时。

### 5. 

首次调用sendto()时

### 6. 

在需要长时间与同一主机进行通信时，调用connect使套接字变成connected已连接套接字可以缩短通信时间，提高效率

### 7. 

#### `uecho_serv2.c` 

```c++
#include <stdio.h>     
#include <stdlib.h>   
#include <string.h>     
#include <unistd.h>    
#include <arpa/inet.h>
#include <sys/socket.h> 
#define BUF_SIZE 30
void error_handling(char* message); 

int main(int argc, char* argv[]) {
    int  serv_sock;
    char message[BUF_SIZE];
    struct sockaddr_in serv_adr, clnt_adr; 
    socklen_t clnt_adr_sz; 
    
    if(argc != 2) { 
        printf("Usage : %s <port>\n", argv[0]);
        exit(1);
    }   
    
    // Creates a UDP socket.
    serv_sock = socket(PF_INET, SOCK_DGRAM, 0); 
    if(serv_sock == -1) error_handling("UDP socket() creation error");
   
    //Initialize the server address structure 
    memset(&serv_adr, 0, sizeof(serv_adr)); 
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_adr.sin_port = htons(atoi(argv[1])); 
   
    int on = 1;
    if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(int)) < 0)  error_handling("setsockopt() error");
    
    if(bind(serv_sock, (struct sockaddr*) &serv_adr, sizeof(serv_adr)) == -1) error_handling("bind() error"); 
     
    int str_len;
    clnt_adr_sz = sizeof(clnt_adr); //initialize clnt_adr_sz
    while (1) {
        //不限制数据传输对象，因此第一个参数不是clnt_sock而是serv_sock
        str_len = recvfrom(serv_sock, message, BUF_SIZE, 0, (struct sockaddr*)&clnt_adr, &clnt_adr_sz);
        message[str_len] = 0;
        printf("Message from clnt: %s", message);
        
        //通过recvfrom的调用同时获取数据传输端的地址，正是利用该地址将接收的数据逆向传输
        fputs("Insert message(Q to quit): ", stdout);
        fgets(message, sizeof(message), stdin);

        if (!strcmp(message, "q\n") || !strcmp(message, "Q\n")) break;

        sendto(serv_sock, message, strlen(message), 0, (struct sockaddr*)&clnt_adr, clnt_adr_sz);
    }
    close(serv_sock); 
    return 0;
}
void error_handling(char* message) {
    perror(message);  
    exit(1);  
}
```

#### `uecho_clnt.c` 不需要变

```c++
#include <stdio.h>     
#include <stdlib.h>   
#include <string.h>     
#include <unistd.h>    
#include <arpa/inet.h>
#include <sys/socket.h> 
#define BUF_SIZE 30
void error_handling(char* message); 

int main(int argc, char* argv[]) {
    int clnt_sock;
    char message[BUF_SIZE];
    struct sockaddr_in serv_adr, from_adr;
    socklen_t src_adr_sz;//接收数据时，数据发送端的socket地址的长度
    if(argc != 3) { 
        printf("Usage : %s <IP> <port>\n", argv[0]);
        exit(1);
    }   

    clnt_sock = socket(PF_INET, SOCK_DGRAM, 0); 
    if(clnt_sock == -1) error_handling("socket() error");

    memset(&serv_adr, 0, sizeof(serv_adr)); 
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_addr.s_addr = inet_addr(argv[1]); 
    serv_adr.sin_port = htons(atoi(argv[2])); 
    
    int str_len;
    while (1) {
        fputs("Insert message(Q to quit): ", stdout);
        fgets(message, sizeof(message), stdin);
        //communication is terminated when the user enters "q" or "Q"
        if (!strcmp(message, "q\n") || !strcmp(message, "Q\n")) break;
        // Send the message to the server
        sendto(clnt_sock, message, strlen(message), 0, (struct sockaddr*)&serv_adr, sizeof(serv_adr));
        // Receive a response from src
        src_adr_sz = sizeof(src_adr);
        str_len = recvfrom(clnt_sock, message, BUF_SIZE , 0, (struct sockaddr*)&src_adr, &src_adr_sz));
        message[str_len] = 0;
        printf("Message from server: %s", message);
    }
    close(clnt_sock);
    return 0;
}
void error_handling(char* message) {
    perror(message);  
    exit(1); 
}
```

## ch07 优雅地断开套接字连接

> 1. 解释TCP中"流"的概念。UDP中能否形成流？请说明原因
> 2. Linux中的close函数或Windows中的closesocket函数属于单方面断开连接的方法，有可能带来一些问题。什么是单方面断开连接？什么情况下会出现问题？
> 3. 什么是半关闭？针对输出流执行半关闭的主机处于何种状态？半关闭会导致对方主机接收什么信息？

### 1. 

tcp中"流"是指：两台主机通过套接字建立连接后进入可交换数据的状态。

udp中无法形成流，因为udp不是面向连接的

### 2. 

单方面断开连接指的是一方未等另一方确认就直接关闭了连接。

当另一方还有数据未传完时。

### 3.

半关闭就是一端在结束发送后还能接收来自另一端的数据，也就是只关闭写（输出流）。

主机半关闭会使其发送最后一个报文段时附带一个EOF，告诉对方主机自己没有数据要发了，但还是可以接收对方主机传送的数据。

## ch08

> 1. 下列关于DNS说法错误的是?
>     b.DNS服务器实际上是路由器，因为路由器根据域名决定数据路径。
>     c.所有域名信息并非集中于1台DNS服务器，但可以获取某一DNS服务器中未注册的IP地址。
>     d. DNS服务器根据操作系统进行区分，Windows下的DNS服务器和Linux下的DNS服务器是不同的。
> 2. 阅读如下对话，并说明东秀的解决方案是否可行。
>     静洙:"东秀吗?我们学校网络中使用的默认DNS服务器发生了故障，无法访问我要投简历的公司主页!有没有办法解决?"
>     东秀:"网络连接正常，但DNS服务器发生了故障?"
>     静洙:"恩!有没有解决方法?是不是要去周围的网吧?"
>     东秀:"有那必要吗?我把我们字校的DNS服务器IP地址告诉你，你改一下你的默认DNS服务器地址。"
>     静洙:"这样可以吗?默认DNS服务器必须连接到本地网络吧!"
>     东秀:"不是!上次我们学校DNS服务器发生故障时，网管就给了我们其他DNS服务器的IP地址呢。"
>     静洙:"那是因为你们学校有多台DNS服务器!"
>     东秀:"是吗?你的话好像也有道理。那你快去网吧吧!"
> 3. 在浏览器地址栏输入www.orentec.co.kr，并整理出网页显示过程。假设浏览器访问的默认DNS服务器中并没有关于www.orentec.co.kr的IP地址信息。

### 1. 

bd

### 2. 

如果网络上没有特别的限制，可以将与本地网络相连的DNS服务器指定为其他完好的DNS服务器。因此，东秀提议的方法可能成为解决方法。也就是说，静洙可以不去网吧。

### 3.

1. **浏览器缓存检查：** 浏览器首先会检查本地缓存，看是否已经有关于 "[www.orentec.co.kr](http://www.orentec.co.kr/)" 的IP地址信息。如果浏览器之前已经访问过这个网站，可能会缓存有关域名的一些信息，包括IP地址。
2. **系统缓存和 hosts 文件检查：** 如果浏览器本地缓存中没有找到相关信息，系统会检查系统缓存和 hosts 文件。
3. **DNS解析：** 如果以上步骤都没有找到相关信息，浏览器将发起DNS请求，向默认的DNS服务器(本地DNS服务器)查询 "[www.orentec.co.kr](http://www.orentec.co.kr/)" 的IP地址。若默认的DNS服务器中DNS缓存没有命中，则默认DNS服务器将根据域名系统的层级结构进行查询:
    1. 它首先**向根**DNS服务器**请求顶级域**（.kr）的DNS服务器的IP地址，
    2. 然后它向**顶级域**（.kr）的DNS服务器发起请求，若没有
    3. 就接着向**二级域**（[co.kr](http://co.kr/)）的DNS服务器发起请求，若还没有
    4. 最后它向**三级域**（[orentec.co.kr](http://orentec.co.kr/)）的DNS服务器发起请求，最终得到所查域名对应的IP地址。
4. **DNS响应：** 
    - 默认DNS服务器（本地DNS服务器）将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
    - 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
    - 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起
5. **建立连接：** 浏览器获得了 "[www.orentec.co.kr](http://www.orentec.co.kr/)" 的IP地址后，它将通过使用 HTTP 或 HTTPS 协议与该IP地址建立连接。
6. **网页加载：** 一旦连接建立，浏览器就会向服务器发送请求，并开始下载网页的 HTML、CSS、JavaScript 等资源。浏览器解析这些资源并渲染页面，最终显示 "[www.orentec.co.kr](http://www.orentec.co.kr/)" 的内容。

这个过程中涉及到多个系统组件，包括**浏览器、本地缓存、系统缓存、hosts 文件、DNS 服务器**等。如果默认的DNS服务器中没有 "[www.orentec.co.kr](http://www.orentec.co.kr/)" 的IP地址信息，整个过程中会涉及到DNS解析过程。

**DNS解析过程：**

![image-20231221174758648](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312211747713.png)

## ch09

> 1. 下列关于Time-wait状态的说法错误的是?
>     a.Time-wait状态只在服务器端的套接字中发生。
>     b.断开连接的四次握手过程中，先传输FIN消息的套接字将进入Time-wait状态。
>     c.Time-wait状态与断开连接的过程无关，而与请求连接过程中SYN消息的传输顺序有关。
>    d. Time-wait状态通常并非必要，应尽可能通过更改套接字可选项防止其发生。
>     
>2. TCP_NODELAY可选项与Nagle算法有关，可通过它禁用Nagle算法。请问何时应考虑禁用Nagle算法?结合收发数据的特性给出说明。 

### 1. 

a,c,d

### 2.

当需要传输大文件数据时，应将`TCP_NODELAY`设为`1`禁用Nagle算法。 因为即便不使用Nagle算法，输出缓冲也会在装满时传输数据包。而将大文件数据传入输出缓冲的操作通常相对较快（也就是说很快就会把输出缓冲装满），因此此时不仅不会增加数据包的数量，反而会在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。

## ch10

> 1. 下列关于进程的说法错误的是？
>
>     a.从操作系统的角度上说，进程是程序运行的单位。
>     b.进程根据创建方式建立父子关系。
>     c.进程可以包含其他进程，即一个进程的内存空间可以包含其他进程。
>     d.子进程可以创建其他子进程，而创建出来的子进程还可以创建其子进程，但所有这些进程只与一个父进程建立父子关系。
>
> 2. 调用fork函数将创建子进程，以下关于子进程描述错误的是？
>
>     a.父进程销毁时也会同时销毁子进程。
>     b.子进程是复制父进程所有资源创建出的进程。
>     c.父子进程共享全局变量。
>     d.通过fork函数创建的子进程将执行从开始到fork函数调用为止的代码。
>
> 3. 创建子进程时将复制父进程的所有内容，此时的复制对象也包含套接字文件描述符。编写程序验证复制的文件描述符整数值是否与原文件描述符整数值相同。
>
> 4. 请说明进程变为僵尸进程的过程及预防措施
>
> 5. 编写注册处理函数的程序，完成功能:“输入Ctrl+C时，询问是否确定退出程序，输入Y则终止程序。”另外，使其每隔1秒输出简单字符串
>

### 1.

c、d 

c：进程的内存空间是独立不共享的

d：？？？

### 2.

 a,c,d

a：孤儿进程就是父进程结束了但子进程还未结束

c：并不共享，每个进程又有独立的内存空间

d：程序是顺序执行的，执行的是调用fork之后的代码

### 3.

`homework3.c`

```c++
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>

int main(int argc, char *argv[]) {
	pid_t pid;

	int sockfd=socket(PF_INET, SOCK_STREAM, 0);

	pid=fork();		

	if(pid==0)
		printf("Child sock fd: [%d] \n", sockfd);
	else
		printf("Parent sock fd: [%d] \n", sockfd);

	return 0;
}
```

输出

```c++
[root@ECSocar ch10]# ./homework3 
Parent sock fd: [3] 
Child sock fd: [3] 
```

### 4.

当子进程终止时，作为参数传递并返回的值将传递到操作系统，并且子进程将变为僵尸进程，直到该值传递给子进程的父进程。为了防止这种情况，父进程必须显式请求子进程的退出值，一旦将此值传递给父进程，子进程将被销毁，且不会保持僵尸状态。

### 5.

`homework5.c`

```c++
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
void ctrl_handler(int sig);

int main(int argc, char *argv[]){
	struct sigaction act;
	act.sa_handler=ctrl_handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags=0;
	sigaction(SIGINT, &act, 0);

	while(1) {
		sleep(1);
		puts("Have a nice day~");
	}
	return 0;
}
void ctrl_handler(int sig){
	char ex;
	fputs("Do you want exit(Y to exit)? ", stdout);
	scanf("%c", &ex);
	if(ex=='y' || ex=='Y') exit(1);
}
```

输出

```c++
[root@ECSocar ch10]# ./homework5
Have a nice day~
Have a nice day~
^CDo you want exit(Y to exit)? n
Have a nice day~
Have a nice day~
Have a nice day~
^CDo you want exit(Y to exit)? Have a nice day~
Have a nice day~
Have a nice day~
^CDo you want exit(Y to exit)? y
```

## ch11

> 1. 什么是进程间通信？分别从概念和内存的角度进行说明
>
> 2. 进程间通信需要特殊的IPC机制，这是由操作系统提供的。进程间通信时为何需要操作系统的帮助？
>
> 3. “管道”是典型的IPC技术。关于管道，请回答如下问题。
>
>     a. 管道是进程间交换数据的路径。如何创建该路径?由谁创建？
>
>     b. 为了完成进程间通信，2个进程需同时连接管道。那2个进程如何连接到同一管道？
>
>     c. 管道允许进行2个进程间的双向通信。双向通信中需要注意哪些内容？
>
> 4. 编写示例复习IPC技术，使2个进程相互交换3次字符串。当然，这2个进程应具有父子关系。

### 1.

从概念上说，进程间通信就是两个进程之间交换数据；

从内存的角度看，只要有两个进程可以共同访问的内存空间，就可以通过此空间交换数据（如管道）。

### 2.

由于两个进程之间并不共享内存，因此需要OS提供共享的内存空间

### 3.

a. 通过pipe函数；由OS创建

b. pipe函数通过输入参数返回管道的输入输出文件描述符。这个文件描述符在fork函数中复制到了其子进程，因此，父进程和子进程可以同时访问同一管道。

c. 管道并不管理进程间的数据通信。因此，如果数据流入管道，任何进程都可以读取数据。因此，要合理安排共享空间的输入和读取。

### 4.

```c++
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#define BUF_SIZE 30

int main(int argc, char *argv[]){
	int fds1[2], fds2[2];
	char buf[BUF_SIZE];

	char str1[] = "Do you like coffee?";
	char str2[] = "I like coffee";
	char str3[] = "I like bread";
	char *str_arr[] = {str1, str2, str3};

	pipe(fds1), pipe(fds2);

	pid_t pid = fork();

	int i;
	if(pid == 0) {  //将三个字符串分三次传给父进程
		for(i = 0; i < 3; i++) {
			write(fds1[1], str_arr[i], strlen(str_arr[i]) + 1);
			read(fds2[0], buf, BUF_SIZE);
			printf("Child proc output: %s \n",  buf);
		}
	}
	else {  //分三次接收三个字符串
		for(i=0; i<3; i++) {
			read(fds1[0], buf, BUF_SIZE);
			printf("Parent proc output: %s \n", buf);
			write(fds2[1], str_arr[i], strlen(str_arr[i]) + 1);
		}
	}
	return 0;
}
```

运行结果

```c++
[root@ECSocar ch11]# ./homework4 
Parent proc output: Do you like coffee? 
Child proc output: Do you like coffee? 
Parent proc output: I like coffee 
Child proc output: I like coffee 
Parent proc output: I like bread 
Child proc output: I like bread
```

## ch12

> 1. 请解释复用技术的通用含义，并说明何为IO复用。
> 2. 多进程并发服务器的缺点有哪些? 如何在I/O复用服务器端中弥补?
> 3. 复用服务器端需要select函数。下列关于select函数使用方法的描述错误的是?
>     a.调用select函数前需要集中IO监视对象的文件描述符。
>     b.若已通过select函数注册为监视对象，则后续调用select函数时无需重复注册。
>     c.复用服务器端同一时间只能服务于1个客户端，因此，需要服务的客户端接入服务器端后只能等待。
>     d.与多进程服务器端不同，基于select的复用服务器端只需要1个进程。因此，可以减少因创建进程产生的服务器端的负担。
> 4.  select函数的观察对象中应包含服务器端套接字（监听套接字)，那么应将其包含到哪一类监听对象集合?请说明原因。
> 5. select函数中使用的fd_set结构体在Windows和Linux中具有不同声明。请说明区别，同时解释存在区别的必然性。

### 1. 

复用就是用最少的物理要素传递最多的数据；

I/O复用就是 将需要I/O的套接字捆绑在一起，利用最少限度的资源来收发数据。

具体的办法是：进程预先告诉内核需要监视的 I/O 事件，使得内核一旦发现进程指定的一个或多个 I/O 事件就绪，就通知进程处理对应事件，从而不会在单个 I/O 上阻塞。

### 2. 

多进程并发服务器的服务方式是，**每当客户端提出连接要求时，就要创建新进程**。但构建进程是一项非常有负担的工作，需要大量的运算和内存空间；由于每个进程都具有独立的内存空间，所以相互间的数据交换也要采用相对复杂的方法（IPC 属于相对复杂的通信方法）。因此，向众多客户端提供服务存在一定的局限性。

而I/O复用服务器则是将套接字的文件描述符**捆绑在一起管理**的方式，因此可以**一个进程**管理所有的I/O操作

### 3. 

bc。

b：调用 select 函数时，操作系统内核将会修改传入 select 函数的第2~4个参数的文件描述符集合，即fd_set结构体变量，以此来通知应用程序哪些文件描述符已经就绪。因此，每次调用 select 函数前都需要重新注册监视的文件描述符。

c：复用服务器同一时间可以受理多个客户端的连接请求，复用服务端也是支持并发的，只要有客户端发送服务请求过来，服务器端都会很快响应，因此与服务器端建立连接后，客户端并不需要等待，可以直接发送数据

### 4. 

服务器端套接字的作用是监听有无客户端的连接请求过来，即服务器端套接字首先需要接收连接请求的消息，因此应将其包含到 “读事件” 类监听对象集合中。

在建立TCP连接过程中，服务器端首先接收到从客户端发来的 SYN 报文段信息，对于服务器端来说，这是一个读事件。

### 5. 

Linux的文件描述符从0开始递增，因此可以找出当前文件描述符数量和最后生成的文件描述符之间的关系。

但Windows的套接字句柄并非从0开始，并且句柄的整数值之间并无规律可循，因此需要直接保存句柄的数组和记录句柄数的变量

## ch13

> 1. 下列关于MSG_OOB可选项的说法错误的是?
>     a. MSG_OOB指传输Out-of-band数据，是通过其他路径高速传输数据。
>     b.MSG _OOB指通过其他路径高速传输数据,因此，TCP中设置该选项的数据先到达对方
>     主机。
>     c.设置MSG OOB使数据先到达对方主机后，以普通数据的形式和顺序读取。也就是说，只是提高了传输速度,接收方无法识别这一点。
>     d. MSG_0OB无法脱离TCP的默认数据传输方式。即使设置了MSG _OOB，也会保持原有传输顺序。该选项只用于要求接收方紧急处理。
> 2. 利用readv & writev函数收发数据有何优点? 分别从函数调用次数和I/O缓冲的角度给出说明。
> 3. 通过recv函数验证输入缓冲是否存在数据时（确认后立即返回时)，如何设置recv函数最
>     后一个参数中的可选项?分别说明各可选项的含义。
> 4. 可在Linux平台通过注册事件处理函数接收MSG_OOB数据。那Windows中如何接收?请
>     说明接收方法。

### 1. 

b,c

a：OOB本意是Out-of-band，即通过其他路径高速传输数据。

### 2.

readv / writev 可以将分散保存在多个缓冲中的数据一并接受 或 发送，能对数据进行整合传输/发送，因此可以进行更有效的数据传输。而且，I/O次数也相应减少，也会产生相应的优势

### 3. 

同时设置MSG_PEEK选项和MSG_DONTWAIT选项，以验证输入缓冲是否存在可接收的数据。设置MSG_PEEK选项并调用recv函数时，即使读取了输入缓冲数据也不会删除。该选项通常与MSG_DONTWAIT合作，用于调用以非阻塞方式验证待读数据存在与否的函数。

### 4.

MSG_OOB数据的接收，在select函数中属于异常数据，既在Windows中可以通过**异常处理**来接收Out-of-band数据

## ch14

> 1. TTL的含义是什么?请从路由器的角度说明较大的TTL值与较小的TTL值之间的区别及问题。
> 2. 多播与广播的异同点是什么?请从数据通信的角度进行说明。
> 3. 下列关于多播的描述错误的是?
>     a.多播是用来向加入多播组的所有主机传输数据的协议。
>     b.主机连接到同一网络才能加入多播组，也就是说，多播组无法跨越多个网络。
>     c.能够加人多播组的主机数并无限制，但只能有1个主机(Sender)向该组发送数据。
>     d.多播时使用的套接字是UDP套接字，因为多播是基于UDP进行数据通信的。
> 4. 多播也对网络流量有利，请比较TCP数据交换方式解释其原因。
> 5. 多播方式的数据通信需要MBone虚拟网络。换言之，MBone是用于多播的网络，但它是虚拟网络。请解释此处的“虚拟网络”。

### 1.

是决定「数据包传递距离」的主要因素，TTL = 数据报最多能经过的路由器的数量；

太大的话则需要经过多次路由器转发，对网络流量造成不良影响；
太小的话，就可能无法到达目的地。

### 2.

异：范围不同。

- 多播能用于不同网络之间，
- 广播只能用于同一网络中。

同：

1. 都是基于UDP进行数据传输
2. 都是「一次性向多个主机发送数据」

### 3.

b,c

### 4.

TCP 是必须建立一对一的连接，如果要向1000个主机发送文件，就得传递1000次。但是此时用多播方式传输数据，就只需要发送一次。

### 5.

通过网络中的特殊协议工作的软件概念上的网络。也就是说， MBone 并非可以触及的物理网络。他是以物理网络为基础，通过软件方法实现的多播通信必备虚拟网络。

# part02

## ch15

> 1. 请说明标准I/O函数的2个优点。它为何拥有这2个优点?
> 2. 利用标准IO函数传输数据时,下面的想法是错误的:“调用fputs函数传输数据时，调用后应立即开始发送!”
>     为何说上述想法是错误的?为了达到这种效果应添加哪些处理过程?

### 1.

 优点：

1. 基于ANSIX标准具有良好的一致性（可移植性）
2. 可以利用缓冲提高性能

### 2.

通过标准输出函数传输的数据是先保存在标准输出函数的缓冲中，然后再用fflush函数进行输出。

因此，即使调用“fputs"函数，也不能立即发送数据。**如果想保障数据传输的时效性，必须调用fflush函数。**

## ch16

> 1. 下列关于FILE结构体指针和文件描述符的说法错误的是?
>     a.与FILE结构体指针相同，文件描述符也分为输入描述符和输出描述符。
>     b.复制文件描述符时将生成相同值的描述符，可以通过这2个描述符进行I/O.
>     ~~c.可以利用创建套接字时返回的文件描述符进行IO，也可以不通过文件描述符，直接通过FILE结构体指针完成。~~
>     d.可以从文件描述符生成FILE结构体指针，而且可以利用这种FILE结构体指针进行套接字IO。
>     e.若文件描述符为读模式，则基于该描述符生成的FILE结构体指针同样是读模式;若文件描述符为写模式，则基于该描述符生成的FILE结构体指针同样是写模式。
> 2. EOF的发送相关描述中错误的是?
>     a.终止文件描述符时发送EOF。
>     b.即使未完全终止文件描述符,关闭输出流时也会发送EOF
>     c.如果复制文件描述符,则包括复制的文件描述符在内,所有描述符都终止时才会发送EOF。
>     d.即使复制文件描述符，也可以通过调用shutdown函数进入半关闭状态并发送EOF。

### 1.

b，d，==a，c==

a：文件描述符不分输入输出。

b："相同值"错了，生成的是不同值

c：?

d："套接字IO"错了，FILE结构体指针是进行标准IO

### 2.

没有错的，全部正确。bcd并不冲突：

b的意思是半关闭(关闭输出流)时会发送EOF；

c是：如果复制了文件描述符，那么这些对应同一套接字的文件描述符中，只要存在没关闭的文件描述符，套接字就还能利用它同时进行I/O，也就是说还能输入输出。因此，要所有描述符都终止时才会发送EOF。

d是：**==调用shutdown函数时，无论复制出多少文件描述符都会进入半关闭状态，并传递EOF。==**

## ch17

> 1. 利用select函数实现服务器端时，代码层面存在的2个缺点是？
> 2. 无论是select方式还是epoll方式，都需要将监视对象文件描述符信息通过函数调用传递给操作系统。请解释传递该信息的原因。
> 3. select方式和epoll方式的最大差异在于监视对象文件描述符传递给操作系统的方式。请说明具体的差异，并解释为何存在这种差异。
> 4. 虽然epoll是select的改进方式，但select也有自己的优点。在何种情况下使用select方式更合理？
> 5. epoll以条件触发或边缘触发方式工作。二者有何区别？从输入缓冲的角度说明这2种方式通知事件的时间点差异。
> 6. 采用边缘触发时可以分离数据的接收和处理时间点。说明其原因及优点。
> 7. 实现聊天服务器，条件触发和边缘触发两种epoll方式实现

### 1.

- 调用select后，要调用**循环**以找出fd_set变量所有监视的发生变化的文件描述符
- 每次调用select前需要复制并保存原有信息，调用select时需要向该函数传递监视对象信息

### 2.

select和epoll是系统函数，准确地说，**是要求观察套接字变化的方式的**。**套接字是受操作系统进行管理的**。即，**select和epoll是一个由操作系统执行的函数**。因此，应该将监视对象的文件描述符传递给操作系统。

### 3.

epoll不同于select的地方是只要向操作系统传递**1次**监视对象。

原因是：select和epoll**在linux内核上保存监视对象信息的方式不同**。

- select：通过fd_set变量保存**所有**监视的文件描述符
- epoll：通过epoll_event结构体数组将**发生事件的**文件描述符集中到一起

### 4.

- 当接入数量不多时（不需要高性能）
- 当程序需要兼容性时

### 5.

条件触发是：只要输入缓冲中还有数据，就会持续进行事件通知（注册事件）。

边缘触发是：收到数据时仅注册一次该事件。

### 6.

原因是：边缘触发方式，在输入缓冲中接收数据时，只会发生一次事件通知。

优点是：

即使输入缓冲收到数据（注册相应事件），服务器端也可以自己决定读取和处理这些数据的时间点。

这样就给服务器的实现带来很大的灵活性。

### 7.待做



```c++
/**********************************char_EPLTserv.c*************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/epoll.h>

#define BUF_SIZE 100
#define MAX_CLNT 256
#define EPOLL_SIZE 50
void error_handling(char *buf);
void send_msg(char * msg, int len);

int clnt_cnt=0;
int clnt_socks[MAX_CLNT];

int main(int argc, char *argv[])
{
	int serv_sock, clnt_sock;
	struct sockaddr_in serv_adr, clnt_adr;
	socklen_t adr_sz;
	int str_len, i;
	char buf[BUF_SIZE];

	struct epoll_event *ep_events;
	struct epoll_event event;
	int epfd, event_cnt;

	if(argc!=2) {
		printf("Usage : %s <port>\n", argv[0]);
		exit(1);
	}

	serv_sock=socket(PF_INET, SOCK_STREAM, 0);
	memset(&serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family=AF_INET;
	serv_adr.sin_addr.s_addr=htonl(INADDR_ANY);
	serv_adr.sin_port=htons(atoi(argv[1]));
	
	if(bind(serv_sock, (struct sockaddr*) &serv_adr, sizeof(serv_adr))==-1)
		error_handling("bind() error");
	if(listen(serv_sock, 5)==-1)
		error_handling("listen() error");

	epfd=epoll_create(EPOLL_SIZE);
	ep_events=malloc(sizeof(struct epoll_event)*EPOLL_SIZE);

	event.events=EPOLLIN;
	event.data.fd=serv_sock;	
	epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &event);

	while(1)
	{
		event_cnt=epoll_wait(epfd, ep_events, EPOLL_SIZE, -1);
		if(event_cnt==-1)
		{
			break;
		}

		for(i=0; i<event_cnt; i++)
		{
			if(ep_events[i].data.fd==serv_sock)
			{
				adr_sz=sizeof(clnt_adr);
				clnt_sock=accept(serv_sock, (struct sockaddr*)&clnt_adr, &adr_sz);
				event.events=EPOLLIN;
				event.data.fd=clnt_sock;
				epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &event);
				clnt_socks[clnt_cnt++]=clnt_sock;
				printf("connected client: %d \n", clnt_sock);
			}
			else
			{
				str_len=read(ep_events[i].data.fd, buf, BUF_SIZE);
				if(str_len==0)  
				{
					epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL);
					close(ep_events[i].data.fd);
					printf("closed client: %d \n", ep_events[i].data.fd);

					for(i=0; i<clnt_cnt; i++) 
					{
						if(clnt_sock==clnt_socks[i])
						{
							while(i++<clnt_cnt-1)
								clnt_socks[i]=clnt_socks[i+1];
							break;
						}
					}
					clnt_cnt--;
				}
				else
				{
					send_msg(buf, str_len);
				}
			}
		}
	}
	close(serv_sock);
	close(epfd);
	return 0;
}

void send_msg(char * msg, int len)   // send to all
{
	int i;
	for(i=0; i<clnt_cnt; i++)
		write(clnt_socks[i], msg, len);
}

void error_handling(char *buf)
{
	fputs(buf, stderr);
	fputc('\n', stderr);
	exit(1);
}



/**********************************char_EPETserv.c*************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/epoll.h>

#define BUF_SIZE 100
#define MAX_CLNT 256
#define EPOLL_SIZE 50

void setnonblockingmode(int fd);
void error_handling(char *buf);
void send_msg(char * msg, int len);

int clnt_cnt=0;
int clnt_socks[MAX_CLNT];

int main(int argc, char *argv[])
{
	int serv_sock, clnt_sock;
	struct sockaddr_in serv_adr, clnt_adr;
	socklen_t adr_sz;
	int str_len, i;
	char buf[BUF_SIZE];

	struct epoll_event *ep_events;
	struct epoll_event event;
	int epfd, event_cnt;

	if(argc!=2) {
		printf("Usage : %s <port>\n", argv[0]);
		exit(1);
	}

	serv_sock=socket(PF_INET, SOCK_STREAM, 0);
	memset(&serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family=AF_INET;
	serv_adr.sin_addr.s_addr=htonl(INADDR_ANY);
	serv_adr.sin_port=htons(atoi(argv[1]));
	
	if(bind(serv_sock, (struct sockaddr*) &serv_adr, sizeof(serv_adr))==-1)
		error_handling("bind() error");
	if(listen(serv_sock, 5)==-1)
		error_handling("listen() error");

	epfd=epoll_create(EPOLL_SIZE);
	ep_events=malloc(sizeof(struct epoll_event)*EPOLL_SIZE);

	setnonblockingmode(serv_sock);
	event.events=EPOL	·LIN;
	event.data.fd=serv_sock;	
	epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &event);

	while(1)
	{
		event_cnt=epoll_wait(epfd, ep_events, EPOLL_SIZE, -1);
		if(event_cnt==-1)
		{
			puts("epoll_wait() error");
			break;
		}

		puts("return epoll_wait");
		for(i=0; i<event_cnt; i++)
		{
			if(ep_events[i].data.fd==serv_sock)
			{
				adr_sz=sizeof(clnt_adr);
				clnt_sock=accept(serv_sock, (struct sockaddr*)&clnt_adr, &adr_sz);
				setnonblockingmode(clnt_sock);
				event.events=EPOLLIN|EPOLLET;
				event.data.fd=clnt_sock;
				epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &event);
				clnt_socks[clnt_cnt++]=clnt_sock;
				printf("connected client: %d \n", clnt_sock);
			}
			else
			{
					while(1)
					{
						str_len=read(ep_events[i].data.fd, buf, BUF_SIZE);
						if(str_len==0)    // close request!
						{
							epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL);
							close(ep_events[i].data.fd);

							for(i=0; i<clnt_cnt; i++) 
							{
								if(ep_events[i].data.fd==clnt_socks[i])
								{
									while(i++<clnt_cnt-1)
										clnt_socks[i]=clnt_socks[i+1];
									break;
								}
							}
							clnt_cnt--;
							printf("closed client: %d \n", ep_events[i].data.fd);
							break;
						}
						else if(str_len<0)
						{
							if(errno==EAGAIN)
								break;
						}
						else
						{
							send_msg(buf, str_len);
						}
				}
			}
		}
	}
	close(serv_sock);
	close(epfd);
	return 0;
}


void send_msg(char * msg, int len)   // send to all
{
	int i;
	for(i=0; i<clnt_cnt; i++)
		write(clnt_socks[i], msg, len);
}
void setnonblockingmode(int fd)
{
	int flag=fcntl(fd, F_GETFL, 0);
	fcntl(fd, F_SETFL, flag|O_NONBLOCK);
}
void error_handling(char *buf)
{
	fputs(buf, stderr);
	fputc('\n', stderr);
	exit(1);
}

```





# 

















 